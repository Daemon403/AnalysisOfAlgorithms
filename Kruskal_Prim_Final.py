# -*- coding: utf-8 -*-
"""Tendai_Nicholas_Candace.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eEuRPfTWLkDtHPr5wB8vxAP0R64tJeOS
"""

import csv
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
from tabulate import tabulate
from google.colab import drive
import time
import seaborn as sns
import random
drive.mount('/content/drive')

"""**Kruskal Algorthm Implementation**"""

# Sorting Edge Function based on weight
def sortEdge(weighted_graph):
    return sorted(weighted_graph, key=lambda x: x[2])

# Parent and Child Function
def find(root, parent):
    while root != parent[root]:
        root = parent[root]
    return root

def union(parent, rootv, rootu, size):
    if size[rootv] > size[rootu]:
        parent[rootu] = rootv
    elif size[rootv] < size[rootu]:
        parent[rootv] = rootu
    else:
        parent[rootu] = rootv
        size[rootv] += 1

# Kruskal Algorithm for MST
def kruskal(weighted_graph, vert_count):
    listMST = []
    sort_graph = sortEdge(weighted_graph)
    parent = list(range(vert_count))
    size = [0] * vert_count

    encounter = 0

    # Iterating over sorted edges
    for k, (v, u, weight) in enumerate(sort_graph):
        rootu = find(v, parent)
        rootv = find(u, parent)
        if rootv != rootu:
            encounter += 1
            listMST.append([v, u, weight])
            union(parent, rootv, rootu, size)
        if encounter == vert_count - 1:
            break

    return listMST

# Reading input File.
file_name = '/content/example_graph.csv'

# Read CSV file into DataFrame
df = pd.read_csv(file_name)

# Collecting all set of vertices
vert_set = set(df['Source'].unique())
vert_set.update(df['Target'].unique())


# Convert the set into a list
vert_list = list(vert_set)
# Maintaining number of all vertices
vert_count = len(vert_set)

# Build a weighted complete graph for Kruskal's algorithm to run
weighted_graph = []
for _, row in df.iterrows():
    weighted_graph.append([
        vert_list.index(row['Source']),
        vert_list.index(row['Target']),
        row['Weight']
    ])

# Run Kruskal's algorithm to find the minimum spanning tree
listMST = kruskal(weighted_graph, vert_count)

# Printing the result
total = sum(edge[2] for edge in listMST)
result_table = [["Order of Visiting Node", "Source", "Target", "Weight"]]
for order, edge in enumerate(listMST):
    source = vert_list[edge[0]]
    target = vert_list[edge[1]]
    weight = edge[2]
    result_table.append([order + 1, source, target, weight])

# Print the result table
for row in result_table:
    print(row)
print("The minimum spanning tree:")
print(tabulate(result_table, headers="firstrow"))
print(f"Total weight: {total} units.")

# Displaying Graph Function
def dGraph(listMST, vert_list):
    # Creating Graph to image
    G = nx.Graph()
    # Recursive Function to adding Edge
    for i in range(len(listMST)):
        G.add_edge(
            vert_list[listMST[i][0]],
            vert_list[listMST[i][1]],
            weight=int(listMST[i][2])
        )
    edge = [(u, v) for (u, v, d) in G.edges(data=True)]

    # Formatting Nodes Position
    position = nx.spring_layout(G, k=20, pos=None, fixed=None, iterations=150, weight='weight', scale=0.5)

    # Reading Weight Edge
    weight = dict(map(lambda x: ((x[0], x[1]), str(x[2]['weight'])), G.edges(data=True)))
    nx.draw_networkx_edge_labels(G, position, edge_labels=weight)

    # Drawing Nodes Function
    nx.draw_networkx_nodes(G, position, node_size=500, node_color='green', node_shape='o', alpha=0.95)

    # Drawing Edges Function
    nx.draw_networkx_edges(G, position, edgelist=edge, width=1.5, edge_color='red', alpha=0.95)

    # Drawing Labels
    nx.draw_networkx_labels(G, position, font_size=12, font_family='sans-serif')

    # Plotting using Matplotlib
    plt.title("Minimum Spanning Tree by Kruskal Algorithm")
    plt.axis('off')
    plt.show()

# Display the results
dGraph(listMST, vert_list)

len(listMST)

"""**Comparison of MST generated by Kruskal and Prim's Algorithm**"""

def make_set(vert):
    return {vert}

def find_set(vert, sets):
    for s in sets:
        if vert in s:
            return s

def merge_sets(set1, set2, sets):
    sets.remove(set1)
    sets.remove(set2)
    merged_set = set1.union(set2)
    sets.append(merged_set)

def add_edge(graph, vertex_1, vertex_2, edge_weight):
    graph[vertex_1].append((vertex_2, edge_weight))
    graph[vertex_2].append((vertex_1, edge_weight))

def read_graph(filename, size):
    vertices = set()
    edges = []
    with open(filename, mode='r') as file:
        csv_reader = csv.reader(file)
        next(csv_reader)
        count = 0
        for line in csv_reader:
            if count >= size:
                break
            vertices.add(line[0])
            vertices.add(line[1])
            edges.append((line[0], line[1], int(line[2])))
            count += 1
    return vertices, edges

def kruskal_algorithm(vertices, edges):
    minimum_spanning_tree = []
    sets = [make_set(vert) for vert in vertices]
    sorted_edges = sorted(edges, key=lambda x: x[2])
    for edge in sorted_edges:
        vertex1, vertex2, weight = edge
        set1 = find_set(vertex1, sets)
        set2 = find_set(vertex2, sets)
        if set1 != set2:
            minimum_spanning_tree.append(edge)
            merge_sets(set1, set2, sets)
    return minimum_spanning_tree

def add_vertex(graph, v):
    if v not in graph:
        graph[v] = []

def prim_read_graph(filename, size):
    vertices = set()
    graph = {}
    with open(filename, mode='r') as file:
        csv_reader = csv.reader(file)
        next(csv_reader)
        count = 0
        for line in csv_reader:
            if count >= size:
                break
            add_vertex(graph, line[0])
            vertices.add(line[0])
            add_vertex(graph, line[1])
            vertices.add(line[1])
            add_edge(graph, line[0], line[1], int(line[2]))
            count += 1
    return graph, vertices

def prims_algorithm(graph, prim_vertices):
    minimum_spanning_tree = []
    visited_vertices = set()
    initial_vertex = next(iter(prim_vertices))
    visited_vertices.add(initial_vertex)
    while len(visited_vertices) < len(prim_vertices):
        min_edge = None
        min_weight = float('inf')
        for vertex in visited_vertices:
            for edge in graph[vertex]:
                if edge[0] not in visited_vertices and edge[1] < min_weight:
                    min_edge = (vertex, edge[0])
                    min_weight = edge[1]

        if min_edge:
            minimum_spanning_tree.append((min_edge[0], min_edge[1], min_weight))
            visited_vertices.add(min_edge[1])
        else:
            initial_vertex = next(iter(prim_vertices - visited_vertices))
            visited_vertices.add(initial_vertex)
    return minimum_spanning_tree


def main():
    input_sizes = [i for i in range(50, 7000, 200)]
    kruskal_execution_times = []
    prim_execution_times = []

    for size in input_sizes:
        vertices, edges = read_graph('/content/example_graph.csv', size)

        listMST = kruskal_algorithm(vertices, edges)
        total = 0
        print("The Kruskal minimum spanning tree Weight : ")

        for a in listMST:
            total += a[2]
        print("total weight: ", total, " units.")

        prim_graph, prim_vertices = prim_read_graph('/content/example_graph.csv', size)
        listMST_prim = prims_algorithm(prim_graph, prim_vertices)

        total = 0
        print("The Prim minimum spanning tree Weight: ")
        for a in listMST_prim:
            total += a[2]
        print("total weight: ", total, " units.")
        print(" ")

if __name__ == "__main__":
    main()

# Run Kruskal's algorithm to find the minimum spanning tree
prim_graph, prim_vertices = prim_read_graph('/content/example_graph.csv', 50)
listMST = prims_algorithm(prim_graph, prim_vertices)

# Printing the result
total = sum(edge[2] for edge in listMST)
result_table = [["Order of Visiting Nodes", "Source", "Target", "Weight"]]
for order, edge in enumerate(listMST):
    source = edge[0]
    target = edge[1]
    weight = edge[2]
    result_table.append([order + 1, source, target, weight])

# Print the result table
for row in result_table:
    print(row)
print("The minimum spanning tree:")
print(tabulate(result_table, headers="firstrow"))
print(f"Total weight: {total} units.")

# Main function for time complexity analysis
def time_complexity_analysis():
    input_sizes = [i for i in range(50, 7000, 200)]
    kruskal_execution_times = []
    prim_execution_times = []

    for size in input_sizes:
        # Kruskal's Algorithm
        vertices_k, edges_k = read_graph('doctorwho.csv', size)
        start_time = time.time()
        kruskal_algorithm(vertices_k, edges_k)
        end_time = time.time()
        kruskal_execution_times.append(end_time - start_time)

        # Prim's Algorithm
        prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
        start_time = time.time()
        prims_algorithm(prim_graph, prim_vertices)
        end_time = time.time()
        prim_execution_times.append(end_time - start_time)

    # Plotting Time Complexity
    sns.set_style("whitegrid")
    plt.plot(input_sizes, kruskal_execution_times, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_execution_times, marker='x', label="Prim's Algorithm")
    plt.title("Time Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Running Time (seconds)")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Tabulating Time Complexity
    df = pd.DataFrame({
        'Input Size': input_sizes,
        "Kruskal's Algorithm": kruskal_execution_times,
        "Prim's Algorithm": prim_execution_times
    })
    print(df)

# Main function for space complexity analysis
def space_complexity_analysis():
    input_sizes = [i for i in range(0, 7000, 250)]
    kruskal_space_complexity = []
    prim_space_complexity = []

    for size in input_sizes:
        # Kruskal's Algorithm
        vertices_k, edges_k = read_graph('doctorwho.csv', size)
        kruskal_space_complexity.append(len(vertices_k) + len(edges_k))

        # Prim's Algorithm
        prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
        total_edges = sum(len(edges) for edges in prim_graph.values())
        prim_space_complexity.append(len(prim_vertices) + total_edges)

    # Plotting Space Complexity
    sns.set_style("whitegrid")
    plt.plot(input_sizes, kruskal_space_complexity, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_space_complexity, marker='x', label="Prim's Algorithm")
    plt.title("Space Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Space Usage")
    plt.legend()
    plt.grid(True)
    plt.show()

# Main function for running time and space complexity analysis
def main():
    time_complexity_analysis()
    space_complexity_analysis()

if __name__ == "__main__":
    main()

def generate_graph_csv(num_vertices, num_edges, filename):
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Source', 'Target', 'Weight'])
        vertices = [str(i) for i in range(num_vertices)]
        edges = set()
        while len(edges) < num_edges:
            v1, v2 = random.sample(vertices, 2)
            weight = random.randint(1, 100)
            if (v1, v2) not in edges and (v2, v1) not in edges:
                edges.add((v1, v2, weight))
        for edge in edges:
            writer.writerow(edge)

# Example usage
num_vertices = 100
num_edges = 10
filename = 'example_graph2.csv'
generate_graph_csv(num_vertices, num_edges, filename)
print(f"Example graph with {num_vertices} vertices and {num_edges} edges generated and saved as '{filename}'.")

# Read the CSV file into a DataFrame
df = pd.read_csv('/content/example_graph.csv')
# Create an empty graph
G = nx.Graph()
print(df.columns)
# Add edges to the graph for the first 20 rows
for _, row in df.iterrows():
    G.add_edge(row['Source'], row['Target'], weight=row['Weight'])

# Draw the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=500, node_color='limegreen', font_size=8, font_weight='bold')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Show the plot
plt.title('Graph before the use of the Prim or Kruskal algorithm')
plt.show()

# Read the CSV file into a DataFrame
df = pd.read_csv('doctorwho.csv')

# Initialize an empty adjacency list
adjacency_list = {}

# Process each row in the DataFrame
for _, row in df.iterrows():
    source = row['Source']
    target = row['Target']
    weight = row['Weight']

    # Add the edge from source to target
    if source not in adjacency_list:
        adjacency_list[source] = []
    adjacency_list[source].append((target, weight))

    # Add the edge from target to source
    if target not in adjacency_list:
        adjacency_list[target] = []
    adjacency_list[target].append((source, weight))

print(adjacency_list)

import pandas as pd
import heapq

def prims(adjacency_list):
    vertices = len(adjacency_list)
    start_vertex = list(adjacency_list.keys())[0]
    visited = {vertex: False for vertex in adjacency_list}
    mst = {}
    pq = []


    for _ in range(vertices - 1):
        visited[start_vertex] = True

        # Explore all edges connected to the current vertex
        for neighbor, weight in adjacency_list[start_vertex]:
            # Add the edge to the priority queue if the neighbor is not visited
            if not visited[neighbor]:
                heapq.heappush(pq, (weight, start_vertex, neighbor))

        # Extract the minimum weighted edge
        while pq:
            weight, u, v = heapq.heappop(pq)
            if not visited[v]:
                break

        # Add the edge to the minimum spanning tree
        if u not in mst:
            mst[u] = []
        if v not in mst:
            mst[v] = []
        mst[u].append((v, weight))
        mst[v].append((u, weight))

        # Update the start vertex to the next unvisited vertex
        start_vertex = v

    return mst

# Read the CSV file into a DataFrame
df = pd.read_csv('example_graph.csv')

# Initialize an empty adjacency list
adjacency_list = {}

# Process each row in the DataFrame
for _, row in df.iterrows():
    source = row['Source']
    target = row['Target']
    weight = row['Weight']

    # Add the edge from source to target
    if source not in adjacency_list:
        adjacency_list[source] = []
    adjacency_list[source].append((target, weight))

    # Add the edge from target to source
    if target not in adjacency_list:
        adjacency_list[target] = []
    adjacency_list[target].append((source, weight))

# Find the minimum spanning tree using Prim's Algorithm
result = prims(adjacency_list)
print("Minimum Spanning Tree (MST):", result)

import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
G = nx.Graph()

# Add nodes to the graph
for vertex in result:
    G.add_node(vertex)

# Add edges to the graph
for vertex, neighbors in result.items():
    for neighbor, weight in neighbors:
        G.add_edge(vertex, neighbor, weight=weight)

# Draw the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=500, node_color='green', font_size=10, font_weight='normal')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Show the plot
plt.title("Minimum Spanning Tree by Prim's Algorithm")
plt.show()