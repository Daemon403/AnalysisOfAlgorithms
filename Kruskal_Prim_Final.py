# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eEuRPfTWLkDtHPr5wB8vxAP0R64tJeOS

**Kruskal Algorthm Implementation**
"""

import csv
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
from tabulate import tabulate

# Sorting Edge Function
def sortEdge(weighted_graph):
    return sorted(weighted_graph, key=lambda x: x[2])  # Sorting based on weight

# Parent and Child Function
def find(root, parent):
    while root != parent[root]:
        root = parent[root]
    return root

def union(parent, rootv, rootu, size):
    if size[rootv] > size[rootu]:
        parent[rootu] = rootv
    elif size[rootv] < size[rootu]:
        parent[rootv] = rootu
    else:
        parent[rootu] = rootv
        size[rootv] += 1

# Kruskal Algorithm for MST
def kruskal(weighted_graph, vert_count):
    listMST = []                            # Empty List for storing MST
    sort_graph = sortEdge(weighted_graph)   # Sorting the Graph according to weight in ascending order
    parent = list(range(vert_count))        # Stores the root vertex to each vertex
    size = [0] * vert_count                 # Number of edging dependents to each vertex

    encounter = 0
    for k, (v, u, weight) in enumerate(sort_graph):  # Iterate over sorted edges
        rootu = find(v, parent)
        rootv = find(u, parent)
        if rootv != rootu:
            encounter += 1
            listMST.append([v, u, weight])
            union(parent, rootv, rootu, size)
        if encounter == vert_count - 1:  # MST is complete
            break

    return listMST

# Reading input File.
file_name = '/content/doctorwho.csv'

# Read CSV file into DataFrame
df = pd.read_csv(file_name)
# df = df.head(100)
# Collecting all set of vertices
vert_set = set(df['Source'].unique())  # Collect unique vertices from the 'Source' column
vert_set.update(df['Target'].unique())  # Collect unique vertices from the 'Target' column

# Convert the set into a list
vert_list = list(vert_set)
# Maintaining number of all vertices
vert_count = len(vert_set)

# Build a weighted complete graph for Kruskal's algorithm to run
weighted_graph = []
for _, row in df.iterrows():
    weighted_graph.append([
        vert_list.index(row['Source']),
        vert_list.index(row['Target']),
        row['Weight']
    ])

# Run Kruskal's algorithm to find the minimum spanning tree
listMST = kruskal(weighted_graph, vert_count)

# Printing the result
total = sum(edge[2] for edge in listMST)
result_table = [["Source", "Target", "Weight"]] + [[vert_list[edge[0]], vert_list[edge[1]], edge[2]] for edge in listMST]
print("The minimum spanning tree:")
print(tabulate(result_table, headers="firstrow"))
print(f"Total weight: {total} units.")

# Displaying Graph Function
def dGraph(listMST, vert_list):
    # Creating Graph to image
    G = nx.Graph()
    # Recursive Function to adding Edge
    for i in range(len(listMST)):
        G.add_edge(
            vert_list[listMST[i][0]],
            vert_list[listMST[i][1]],
            weight=int(listMST[i][2])
        )
    edge = [(u, v) for (u, v, d) in G.edges(data=True)]

    # Formatting Nodes Position
    position = nx.spring_layout(G, k=20, pos=None, fixed=None, iterations=150, weight='weight', scale=0.5)

    # Reading Weight Edge
    weight = dict(map(lambda x: ((x[0], x[1]), str(x[2]['weight'])), G.edges(data=True)))
    nx.draw_networkx_edge_labels(G, position, edge_labels=weight)

    # Drawing Nodes Function
    nx.draw_networkx_nodes(G, position, node_size=250, node_color='green', node_shape='o', alpha=0.95)

    # Drawing Edges Function
    nx.draw_networkx_edges(G, position, edgelist=edge, width=1.5, edge_color='red', alpha=0.95)

    # Drawing Labels
    nx.draw_networkx_labels(G, position, font_size=8, font_family='sans-serif')

    # Plotting using Matplotlib
    plt.axis('off')
    plt.show()

# Display the results
dGraph(listMST[680:], vert_list)

len(listMST)

"""**Prim's Implementation**"""

# import matplotlib.pyplot as plt
# import networkx as nx
# import pandas as pd

# def prim(weighted_graph):
#     listMST = []        # Empty List for storing MST
#     visited = []        # Empty List for storing the Node that have been visited
#     edge_list = []      # Storing the Edges Values

#     #Minimum Edge Weight
#     min_edge = [0, 1, weighted_graph[0][1]]

#     v = 0
#     for V in range(vert_count - 1):
#         # add current vertex to the visited list
#         visited.append(v)

#         # updated the edge list with every current
#         # candidate that can be a minimum-weight edge
#         for u in range(vert_count):
#             if weighted_graph[v][u] != 0 and u not in visited:
#                 edge_list.append([v, u, weighted_graph[v][u]])

#         # find a minimum-weight edge among all the edge candidates
#         for e in range(1, len(edge_list)):
#             if edge_list[e][2] < min_edge[2] and edge_list[e][1] not in visited:
#                 min_edge = edge_list[e]

#         # updated the MST list with the discovered minimum-weight edge
#         listMST.append(min_edge)

#         v = min_edge[1] # traverse to next vertex

#         # remove the used minimum-weight edge
#         edge_list.remove(min_edge)
#         if edge_list:
#             min_edge = edge_list[0]

#     return listMST
#     # Output: The empty set filled with the minimum spanning tree of G

# file_name = '/content/doctorwho.csv'

# # Read CSV file into DataFrame
# df = pd.read_csv(file_name)

# vert_set = set(df['Source'].unique())
# vert_set.update(df['Target'].unique())
# vert_list = list(vert_set)
# vert_count = len(vert_set)
# weighted_graph = [[0 for i in range(vert_count)] for j in range(vert_count)]

# for _, row in df.iterrows():
#     weighted_graph[vert_list.index(row['Source'])][vert_list.index(row['Target'])] = row['Weight']
#     weighted_graph[vert_list.index(row['Target'])][vert_list.index(row['Source'])] = row['Weight']

# listMST = prim(weighted_graph)

# total = 0
# print("The minimum spanning tree : ")
# for a in range(len(listMST)):
#     print(vert_list[listMST[a][0]], " to ", vert_list[listMST[a][1]], " = ", listMST[a][2], " units.")
#     total += listMST[a][2]
# print("total weight: ", total, " units.")

# dGraph(listMST,vert_list)

import csv
import time
import matplotlib.pyplot as plt

def make_set(vert):
    return {vert}

def find_set(vert, sets):
    for s in sets:
        if vert in s:
            return s

def merge_sets(set1, set2, sets):
    sets.remove(set1)
    sets.remove(set2)
    merged_set = set1.union(set2)
    sets.append(merged_set)

def add_edge(graph, vertex_1, vertex_2, edge_weight):
    graph[vertex_1].append((vertex_2, edge_weight))
    graph[vertex_2].append((vertex_1, edge_weight))

def read_graph(filename, size):
    vertices = set()
    edges = []
    with open(filename, mode='r') as file:
        csv_reader = csv.reader(file)
        next(csv_reader)
        count = 0
        for line in csv_reader:
            if count >= size:
                break
            vertices.add(line[0])
            vertices.add(line[1])
            edges.append((line[0], line[1], int(line[2])))
            count += 1
    return vertices, edges

def kruskal_algorithm(vertices, edges):
    minimum_spanning_tree = []
    sets = [make_set(vert) for vert in vertices]
    sorted_edges = sorted(edges, key=lambda x: x[2])
    for edge in sorted_edges:
        vertex1, vertex2, weight = edge
        set1 = find_set(vertex1, sets)
        set2 = find_set(vertex2, sets)
        if set1 != set2:
            minimum_spanning_tree.append(edge)
            merge_sets(set1, set2, sets)
    return minimum_spanning_tree

def add_vertex(graph, v):
    if v not in graph:
        graph[v] = []

def prim_read_graph(filename, size):
    vertices = set()
    graph = {}
    with open(filename, mode='r') as file:
        csv_reader = csv.reader(file)
        next(csv_reader)
        count = 0
        for line in csv_reader:
            if count >= size:
                break
            add_vertex(graph, line[0])
            vertices.add(line[0])
            add_vertex(graph, line[1])
            vertices.add(line[1])
            add_edge(graph, line[0], line[1], int(line[2]))
            count += 1
    return graph, vertices

def prims_algorithm(graph, prim_vertices):
    minimum_spanning_tree = []
    visited_vertices = set()
    initial_vertex = next(iter(prim_vertices))
    visited_vertices.add(initial_vertex)
    while len(visited_vertices) < len(prim_vertices):
        min_edge = None
        min_weight = float('inf')
        for vertex in visited_vertices:
            for edge in graph[vertex]:
                if edge[0] not in visited_vertices and edge[1] < min_weight:
                    min_edge = (vertex, edge[0])
                    min_weight = edge[1]

        if min_edge:
            minimum_spanning_tree.append((min_edge[0], min_edge[1], min_weight))
            visited_vertices.add(min_edge[1])
        else:
            initial_vertex = next(iter(prim_vertices - visited_vertices))
            visited_vertices.add(initial_vertex)
    return minimum_spanning_tree


def main():
    input_sizes = [i for i in range(50, 7000, 200)]
    kruskal_execution_times = []
    prim_execution_times = []

    for size in input_sizes:
        vertices, edges = read_graph('/content/doctorwho.csv', size)

        listMST = kruskal_algorithm(vertices, edges)
        total = 0
        print("The Kruskal minimum spanning tree Weight : ")
        for a in listMST:
            print(a[0], " to ", a[1], " = ", a[2], " units.")
            total += a[2]
        print("total weight: ", total, " units.")

        prim_graph, prim_vertices = prim_read_graph('/content/doctorwho.csv', size)
        listMST = prims_algorithm(prim_graph, prim_vertices)

        total = 0
        print("The Prim minimum spanning tree Weight: ")
        for a in listMST:
            print(a[0], " to ", a[1], " = ", a[2], " units.")
            total += a[2]
        print("total weight: ", total, " units.")
        print(" ")

if __name__ == "__main__":
    main()

import csv
import time
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Main function for time complexity analysis
def time_complexity_analysis():
    input_sizes = [i for i in range(50, 7000, 200)]
    kruskal_execution_times = []
    prim_execution_times = []

    for size in input_sizes:
        # Kruskal's Algorithm
        vertices_k, edges_k = read_graph('doctorwho.csv', size)
        start_time = time.time()
        kruskal_algorithm(vertices_k, edges_k)
        end_time = time.time()
        kruskal_execution_times.append(end_time - start_time)

        # Prim's Algorithm
        prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
        start_time = time.time()
        prims_algorithm(prim_graph, prim_vertices)
        end_time = time.time()
        prim_execution_times.append(end_time - start_time)

    # Plotting Time Complexity
    sns.set_style("whitegrid")
    plt.plot(input_sizes, kruskal_execution_times, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_execution_times, marker='x', label="Prim's Algorithm")
    plt.title("Time Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Running Time (seconds)")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Tabulating Time Complexity
    df = pd.DataFrame({
        'Input Size': input_sizes,
        "Kruskal's Algorithm": kruskal_execution_times,
        "Prim's Algorithm": prim_execution_times
    })
    print(df)

# Main function for space complexity analysis
def space_complexity_analysis():
    input_sizes = [i for i in range(0, 7000, 250)]
    kruskal_space_complexity = []
    prim_space_complexity = []

    for size in input_sizes:
        # Kruskal's Algorithm
        vertices_k, edges_k = read_graph('doctorwho.csv', size)
        kruskal_space_complexity.append(len(vertices_k) + len(edges_k))

        # Prim's Algorithm
        prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
        total_edges = sum(len(edges) for edges in prim_graph.values())
        prim_space_complexity.append(len(prim_vertices) + total_edges)

    # Plotting Space Complexity
    sns.set_style("whitegrid")
    plt.plot(input_sizes, kruskal_space_complexity, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_space_complexity, marker='x', label="Prim's Algorithm")
    plt.title("Space Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Space Usage")
    plt.legend()
    plt.grid(True)
    plt.show()

# Main function for running time and space complexity analysis
def main():
    time_complexity_analysis()
    space_complexity_analysis()

if __name__ == "__main__":
    main()

import csv
import time
import statistics
import random
import networkx as nx
import matplotlib.pyplot as plt
from cProfile import Profile

# Main function for time complexity analysis
def time_complexity_analysis():
    input_sizes = [i for i in range(50, 7000, 250)]
    num_runs = 5  # Number of runs for each input size

    kruskal_avg_times = []
    prim_avg_times = []

    for size in input_sizes:
        kruskal_times = []
        prim_times = []
        for _ in range(num_runs):
            # Kruskal's Algorithm
            start_time = time.time()
            kruskal_algorithm(vertices_k, edges_k)
            end_time = time.time()
            kruskal_times.append(end_time - start_time)

            # Prim's Algorithm
            prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
            start_time = time.time()
            prims_algorithm(prim_graph, prim_vertices)
            end_time = time.time()
            prim_times.append(end_time - start_time)

        kruskal_avg_times.append(statistics.mean(kruskal_times))
        prim_avg_times.append(statistics.mean(prim_times))

    # Plotting Time Complexity
    plt.plot(input_sizes, kruskal_avg_times, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_avg_times, marker='x', label="Prim's Algorithm")
    plt.title("Average Time Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Average Running Time (seconds)")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Print table of average times
    print("Input Size\tKruskal's Avg Time\tPrim's Avg Time")
    for i in range(len(input_sizes)):
        print(f"{input_sizes[i]}\t\t{kruskal_avg_times[i]}\t\t{prim_avg_times[i]}")

# Main function for running time complexity analysis
def main():
    time_complexity_analysis()

if __name__ == "__main__":
    main()

# Main function for time complexity analysis
def time_complexity_analysis():
    input_sizes = [i for i in range(50, 7000, 250)]
    num_runs = 5  # Number of runs for each input size

    kruskal_avg_times = []
    prim_avg_times = []

    for size in input_sizes:
        kruskal_times = []
        prim_times = []
        for _ in range(num_runs):
            # Kruskal's Algorithm
            vertices_k, edges_k = generate_random_graph(size, size * 2)
            start_time = time.time()
            kruskal_algorithm(vertices_k, edges_k)
            end_time = time.time()
            kruskal_times.append(end_time - start_time)

            # Prim's Algorithm
            prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
            start_time = time.time()
            prims_algorithm(prim_graph, prim_vertices)
            end_time = time.time()
            prim_times.append(end_time - start_time)

        kruskal_avg_times.append(statistics.mean(kruskal_times))
        prim_avg_times.append(statistics.mean(prim_times))

    # Plotting Time Complexity
    plt.plot(input_sizes, kruskal_avg_times, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_avg_times, marker='x', label="Prim's Algorithm")
    plt.title("Average Time Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Average Running Time (seconds)")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Print table of average times
    print("Input Size\tKruskal's Avg Time\tPrim's Avg Time")
    for i in range(len(input_sizes)):
        print(f"{input_sizes[i]}\t\t{kruskal_avg_times[i]}\t\t{prim_avg_times[i]}")

    # Big O Notation Analysis
    print("\nBig O Notation Analysis:")
    print("Kruskal's Algorithm: O(E log E + E Î±(V))")
    print("Prim's Algorithm: O((V + E) log V)")

# Main function for running time complexity analysis
def main():
    time_complexity_analysis()

if __name__ == "__main__":
    main()

import csv
import random

def generate_graph_csv(num_vertices, num_edges, filename):
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Source', 'Target', 'Weight'])
        vertices = [str(i) for i in range(num_vertices)]
        edges = set()
        while len(edges) < num_edges:
            v1, v2 = random.sample(vertices, 2)
            weight = random.randint(1, 100)
            if (v1, v2) not in edges and (v2, v1) not in edges:
                edges.add((v1, v2, weight))
        for edge in edges:
            writer.writerow(edge)

# Example usage
num_vertices = 100
num_edges = 10
filename = 'example_graph2.csv'
generate_graph_csv(num_vertices, num_edges, filename)
print(f"Example graph with {num_vertices} vertices and {num_edges} edges generated and saved as '{filename}'.")

import heapq

def prims(adjacency_list, vertices, start_vertex):
    mst = {}  # To store the minimum spanning tree
    visited = [False] * vertices  # To keep track of visited vertices
    pq = []  # Priority queue to store edges

    # Start with the given start_vertex
    current = start_vertex
    visited[current] = True

    # Main loop
    for _ in range(vertices - 1):  # Need to add (vertices - 1) edges to form MST
        # Explore all edges connected to the current vertex
        for neighbor, weight in adjacency_list[current]:
            # Add the edge to the priority queue if the neighbor is not visited
            if not visited[neighbor]:
                heapq.heappush(pq, (weight, current, neighbor))

        # Extract the minimum weighted edge
        while pq:
            weight, u, v = heapq.heappop(pq)
            if not visited[v]:
                break

        # Add the edge to the minimum spanning tree
        if u not in mst:
            mst[u] = []
        if v not in mst:
            mst[v] = []
        mst[u].append((v, weight))
        mst[v].append((u, weight))

        # Mark the adjacent vertex as visited and update the current vertex
        visited[v] = True
        current = v

    return mst

# Example usage:
adjacency_list = {
    0: [(1, 2), (2, 3)],
    1: [(0, 2), (2, 1)],
    2: [(0, 2), (1, 1)],
    3: [(0, 2), (1, 1)],
    4: [(0, 2), (2, 1)],
    5: [(0, 2), (2, 1), (1, 1)]
}
vertices = 6
start_vertex = 0

result = prims(adjacency_list, vertices, start_vertex)
print("Minimum Spanning Tree (MST):", result)

import networkx as nx
import matplotlib.pyplot as plt

# Example adjacency list representation of the graph
adjacency_list = {
    0: [(1, 2), (2, 3)],
    1: [(0, 2), (2, 1)],
    2: [(0, 2), (1, 1)],
    3: [(0, 2), (1, 1)],
    4: [(0, 2), (2, 1)],
    5: [(0, 2), (2, 1), (1, 1)]
}

# Create an empty graph
G = nx.Graph()

# Add nodes to the graph
for vertex in adjacency_list:
    G.add_node(vertex)

# Add edges to the graph
for vertex, neighbors in adjacency_list.items():
    for neighbor, weight in neighbors:
        G.add_edge(vertex, neighbor, weight=weight)

# Draw the graph
pos = nx.spring_layout(G)  # Positions of the nodes
nx.draw(G, pos, with_labels=True, node_size=500, node_color='green', font_size=12, font_weight='bold')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Show the plot
plt.title('Graph')
plt.show()

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# Read the CSV file into a DataFrame
df = pd.read_csv('/content/example_graph.csv')
# Create an empty graph
G = nx.Graph()
print(df.columns)
# Add edges to the graph for the first 20 rows
for _, row in df.iterrows():
    G.add_edge(row['Source'], row['Target'], weight=row['Weight'])

# Draw the graph
pos = nx.spring_layout(G)  # Positions of the nodes
nx.draw(G, pos, with_labels=True, node_size=500, node_color='limegreen', font_size=8, font_weight='bold')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Show the plot
plt.title('Graph')
plt.show()

df

import pandas as pd

# Read the CSV file into a DataFrame
df = pd.read_csv('doctorwho.csv')

# Initialize an empty adjacency list
adjacency_list = {}

# Process each row in the DataFrame
for _, row in df.iterrows():
    source = row['Source']
    target = row['Target']
    weight = row['Weight']

    # Add the edge from source to target
    if source not in adjacency_list:
        adjacency_list[source] = []
    adjacency_list[source].append((target, weight))

    # Add the edge from target to source
    if target not in adjacency_list:
        adjacency_list[target] = []
    adjacency_list[target].append((source, weight))

print(adjacency_list)

import pandas as pd
import heapq

def prims(adjacency_list):
    vertices = len(adjacency_list)
    start_vertex = list(adjacency_list.keys())[0]  # Setting the first vertex as the start vertex
    visited = {vertex: False for vertex in adjacency_list}  # Using a dictionary for visited vertices

    mst = {}  # To store the minimum spanning tree
    pq = []  # Priority queue to store edges

    # Main loop
    for _ in range(vertices - 1):  # Need to add (vertices - 1) edges to form MST
        # Mark the current vertex as visited
        visited[start_vertex] = True

        # Explore all edges connected to the current vertex
        for neighbor, weight in adjacency_list[start_vertex]:
            # Add the edge to the priority queue if the neighbor is not visited
            if not visited[neighbor]:
                heapq.heappush(pq, (weight, start_vertex, neighbor))

        # Extract the minimum weighted edge
        while pq:
            weight, u, v = heapq.heappop(pq)
            if not visited[v]:
                break

        # Add the edge to the minimum spanning tree
        if u not in mst:
            mst[u] = []
        if v not in mst:
            mst[v] = []
        mst[u].append((v, weight))
        mst[v].append((u, weight))

        # Update the start vertex to the next unvisited vertex
        start_vertex = v

    return mst

# Read the CSV file into a DataFrame
df = pd.read_csv('example_graph.csv')

# Initialize an empty adjacency list
adjacency_list = {}

# Process each row in the DataFrame
for _, row in df.iterrows():
    source = row['Source']
    target = row['Target']
    weight = row['Weight']

    # Add the edge from source to target
    if source not in adjacency_list:
        adjacency_list[source] = []
    adjacency_list[source].append((target, weight))

    # Add the edge from target to source
    if target not in adjacency_list:
        adjacency_list[target] = []
    adjacency_list[target].append((source, weight))

# Find the minimum spanning tree using Prim's Algorithm
result = prims(adjacency_list)
print("Minimum Spanning Tree (MST):", result)

import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
G = nx.Graph()

# Add nodes to the graph
for vertex in adjacency_list:
    G.add_node(vertex)

# Add edges to the graph
for vertex, neighbors in adjacency_list.items():
    for neighbor, weight in neighbors:
        G.add_edge(vertex, neighbor, weight=weight)

# Draw the graph
pos = nx.spring_layout(G)  # Positions of the nodes
nx.draw(G, pos, with_labels=True, node_size=500, node_color='green', font_size=12, font_weight='bold')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Show the plot
plt.title('Graph')
plt.show()

import csv
import time
import statistics
import random
import networkx as nx
import matplotlib.pyplot as plt

# Function to initialize a new set for a vertex
def make_set(vert):
    return {vert}

# Function to find the set in which the given vertex belongs
def find_set(vert, sets):
    for s in sets:
        if vert in s:
            return s

# Function to merge two sets
def merge_sets(set1, set2, sets):
    sets.remove(set1)
    sets.remove(set2)
    merged_set = set1.union(set2)
    sets.append(merged_set)

# Function to add an edge to the minimum spanning tree in Kruskal's algorithm
def add_edge_kruskal(edge, minimum_spanning_tree, sets):
    vertex1, vertex2, weight = edge
    set1 = find_set(vertex1, sets)
    set2 = find_set(vertex2, sets)
    if set1 != set2:
        minimum_spanning_tree.append(edge)
        merge_sets(set1, set2, sets)

# Function to add an edge between vertices with a specified weight in Prim's algorithm
def add_edge_prim(graph, vertex_1, vertex_2, edge_weight):
    graph[vertex_1].append([vertex_2, edge_weight])
    graph[vertex_2].append([vertex_1, edge_weight])

# Function to read graph data from CSV and initialize vertices and edges
def read_graph(filename, size):
    vertices = set()
    edges = []
    with open(filename, mode='r') as file:
        csvFile = csv.reader(file)
        next(csvFile)
        count = 0
        for lines in csvFile:
            if count >= size:
                break
            vertices.add(lines[0])
            vertices.add(lines[1])
            edges.append((lines[0], lines[1], int(lines[2])))
            count += 1
    return vertices, edges

# Kruskal's algorithm implementation
def kruskal_algorithm(vertices, edges):
    minimum_spanning_tree = []
    sets = [make_set(vert) for vert in vertices]
    sorted_edges = sorted(edges, key=lambda x: x[2])
    total_weight = 0  # Initialize total weight
    for edge in sorted_edges:
        add_edge_kruskal(edge, minimum_spanning_tree, sets)
        total_weight += edge[2]  # Add edge weight to total weight
    return minimum_spanning_tree, total_weight

# Function to add vertices to the graph
def add_vertex(graph, v):
    if v not in graph:
        graph[v] = []

# Function to read graph data from CSV and initialize vertices and edges for Prim's algorithm
def prim_read_graph(filename, size):
    vertices = set()
    graph = {}
    with open(filename, mode='r') as file:
        csvFile = csv.reader(file)
        next(csvFile)
        count = 0
        for lines in csvFile:
            if count >= size:  # Limiting the number of lines to read
                break
            add_vertex(graph, lines[0])
            vertices.add(lines[0])
            add_vertex(graph, lines[1])
            vertices.add(lines[1])
            add_edge_prim(graph, lines[0], lines[1], int(lines[2]))
            count += 1
    return graph, vertices

# Prim's algorithm implementation
def prims_algorithm(graph, prim_vertices):
    minimum_spanning_tree = []
    visited_vertices = set()
    initial_vertex = next(iter(prim_vertices))
    visited_vertices.add(initial_vertex)
    total_weight = 0  # Initialize total weight
    while len(visited_vertices) < len(prim_vertices):
        min_edge = None
        min_weight = float('inf')
        for vertex in visited_vertices:
            for edge in graph[vertex]:
                if edge[0] not in visited_vertices and edge[1] < min_weight:
                    min_edge = (vertex, edge[0])
                    min_weight = edge[1]

        if min_edge:
            minimum_spanning_tree.append((min_edge[0], min_edge[1], min_weight))
            visited_vertices.add(min_edge[1])
            total_weight += min_weight  # Add edge weight to total weight
        else:
            initial_vertex = next(iter(prim_vertices - visited_vertices))
            visited_vertices.add(initial_vertex)
    return minimum_spanning_tree, total_weight

# Generate a random graph
def generate_random_graph(num_vertices, num_edges):
    vertices = [str(i) for i in range(num_vertices)]
    edges = []
    for _ in range(num_edges):
        v1, v2 = random.sample(vertices, 2)
        weight = random.randint(1, 100)  # Assuming weights between 1 and 100
        edges.append((v1, v2, weight))
    return vertices, edges

# Main function for time complexity analysis
def time_complexity_analysis():
    input_sizes = [i for i in range(50, 7000, 250)]
    num_runs = 5  # Number of runs for each input size

    kruskal_avg_times = []
    prim_avg_times = []
    kruskal_avg_weights = []  # List to store average weights of MSTs for Kruskal's algorithm
    prim_avg_weights = []  # List to store average weights of MSTs for Prim's algorithm

    for size in input_sizes:
        kruskal_times = []
        prim_times = []
        kruskal_weights = []  # List to store weights of MSTs for Kruskal's algorithm
        prim_weights = []  # List to store weights of MSTs for Prim's algorithm

        for _ in range(num_runs):
            # Kruskal's Algorithm
            vertices_k, edges_k = generate_random_graph(size, size * 2)
            start_time = time.time()
            mst_kruskal, weight_kruskal = kruskal_algorithm(vertices_k, edges_k)
            end_time = time.time()
            kruskal_times.append(end_time - start_time)
            kruskal_weights.append(weight_kruskal)

            # Prim's Algorithm
            prim_graph, prim_vertices = prim_read_graph('doctorwho.csv', size)
            start_time = time.time()
            mst_prim, weight_prim = prims_algorithm(prim_graph, prim_vertices)
            end_time = time.time()
            prim_times.append(end_time - start_time)
            prim_weights.append(weight_prim)

        kruskal_avg_times.append(statistics.mean(kruskal_times))
        prim_avg_times.append(statistics.mean(prim_times))
        kruskal_avg_weights.append(statistics.mean(kruskal_weights))
        prim_avg_weights.append(statistics.mean(prim_weights))

    # Plotting Time Complexity
    plt.plot(input_sizes, kruskal_avg_times, marker='o', label="Kruskal's Algorithm")
    plt.plot(input_sizes, prim_avg_times, marker='x', label="Prim's Algorithm")
    plt.title("Average Time Complexity Analysis")
    plt.xlabel("Input Size")
    plt.ylabel("Average Running Time (seconds)")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Print table of average times and weights
    print("Input Size\tKruskal's Avg Time\tPrim's Avg Time\tKruskal's Avg Weight\tPrim's Avg Weight")
    for i in range(len(input_sizes)):
        print(f"{input_sizes[i]}\t\t{kruskal_avg_times[i]}\t\t{prim_avg_times[i]}\t\t{kruskal_avg_weights[i]}\t\t{prim_avg_weights[i]}")

# Main function for running time complexity analysis
def main():
    time_complexity_analysis()

if __name__ == "__main__":
    main()